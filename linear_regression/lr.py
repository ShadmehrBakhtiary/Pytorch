# -*- coding: utf-8 -*-
"""linear_regression.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1bVP-VLBhV1JRcZs5PPO44ttCaChkLheL

# **Linear regression using pytorch*

import all libraries
"""

from google.colab import drive
drive.mount('/content/drive')

# Commented out IPython magic to ensure Python compatibility.
import torch
import torch.nn as nn
import torch.optim as optim
from torch.utils.data import DataLoader, TensorDataset
import seaborn as sns
from sklearn.model_selection import train_test_split
import matplotlib.pyplot as plt
import pandas as pd
# %matplotlib inline

"""import our dataset"""

data = pd.read_csv("/content/drive/MyDrive/ML_FOLDER/pytorch/data/fuel.csv")
data.info()
data.head()

cols = data.columns
plt.figure(figsize=(20, 15))
for index, column in enumerate(cols):
    plt.subplot(5, 4, index + 1)
    sns.scatterplot(x=column, y='CO2EMISSIONS', data=data, color="blue")
    plt.title(f"{column} vs CO2EMISSIONS", fontweight="black", size=10, pad=10)
    plt.tight_layout()
plt.show()

"""we are going to performe our model base on FUELCONSUMPTION_HWY and  CO2EMISSIONS"""

data = data[['CO2EMISSIONS', 'FUELCONSUMPTION_HWY']]

data.shape

"""# spliting data to train and test sets"""

from sklearn.model_selection import train_test_split
train_X, test_X, train_y, test_y = train_test_split(data.drop('CO2EMISSIONS',axis=1).values,
                                                    data['CO2EMISSIONS'].values, test_size=0.2,
                                                    random_state=33)

# Update the training loop to use training data
X_train = torch.FloatTensor(train_X)
X_test = torch.FloatTensor(test_X)
y_train = torch.FloatTensor(train_y).reshape(-1, 1)  # Change to torch.FloatTensor
y_test = torch.FloatTensor(test_y).reshape(-1, 1)  # Change to torch.FloatTensor

print(f'Training size: {len(y_train)}')
labels, counts = y_train.unique(return_counts=True)
print(f'Labels: {labels}\nCounts: {counts}')

X_train.size()

y_train.size()

"""# Define the model"""

class LinearRegression(nn.Module):
    def __init__(self, input_dim, output_dim):
        super(LinearRegression, self).__init__()
        self.linear = nn.Linear(input_dim, output_dim)

    def forward(self, x):
        return self.linear(x)

input_dim = X_train.size(1)
output_dim = y_train.size(1)
model = LinearRegression(input_dim, output_dim)

# Define the loss function and optimizer
criterion = nn.MSELoss()
optimizer = optim.SGD(model.parameters(), lr=0.01)

"""# Training the model"""

num_epochs = 1000
for epoch in range(num_epochs):
    optimizer.zero_grad()
    outputs = model(X_train)
    loss = criterion(outputs, y_train)
    loss.backward()
    optimizer.step()

    if (epoch+1) % 100 == 0:
        print(f'Epoch [{epoch+1}/{num_epochs}], Loss: {loss.item()}')

"""# EVALUTE THE MODEL"""

model.eval()
with torch.no_grad():
    y_pred = model(X_test)
    test_loss = criterion(y_pred, y_test)
    print(f'Test Loss: {test_loss.item()}')

X_test_np = X_test.numpy()
y_test_np = y_test.numpy()
y_pred_np = y_pred.numpy()

# Plot actual vs. predicted values
plt.figure(figsize=(8, 6))
plt.scatter(X_test_np, y_test_np, color='blue', label='Actual')
plt.plot(X_test_np, y_pred_np, color='red', linewidth=2, label='Predicted')
plt.xlabel('X_test')
plt.ylabel('y')
plt.title('Actual vs. Predicted values')
plt.legend()
plt.show()